package com.hp.hpl.jena.query.darq.engine.optimizer.planoperators;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

import com.hp.hpl.jena.graph.Triple;
import com.hp.hpl.jena.query.darq.core.MapServiceGroup;
import com.hp.hpl.jena.query.darq.engine.optimizer.PlanUnfeasibleException;
import com.hp.hpl.jena.query.engine1.PlanElement;
import com.hp.hpl.jena.query.util.Context;

/*
 * kann sein, dass noch mehr Methoden ausser joins verändert werden müssen
 */
public abstract class MapPlanOperatorBase implements Comparable<MapPlanOperatorBase> {

	/**
	 * costs per result
	 */
	public final static double CT = 5;

	/**
	 * costs per request
	 */
	public final static double CR = 20;

	private double cachedResultSize = -1;

	private double cachedCosts = -1;

	private Set<MapServiceGroup> serviceGroups = null;

	private Set<String> boundVariables = null;

	// public final static double SEL = 1 / 100; // TODO FIXME : Replace with
	// better estimation!!

	public abstract double getCosts_() throws PlanUnfeasibleException;

	public double getCosts() throws PlanUnfeasibleException {
		if (cachedCosts == -1)
			cachedCosts = getCosts_();
		return cachedCosts;
	}

	/*
	 * This function is for joins
	 */
	public abstract double getResultsize(Set<String> boundVariables ) throws PlanUnfeasibleException;
	

	/*
	 * Implementierung von getResultsize
	 * 1. Braucht jeder POb eine?
	 * 
	 */
	public double getResultsize() throws PlanUnfeasibleException {
		if (cachedResultSize == -1)
			cachedResultSize = getResultsize(null);
		return cachedResultSize;

	}

	public Set<String> getBoundVariables() {
		if (boundVariables == null)
			boundVariables = getBoundVariables_();
		return boundVariables;
	}

	public abstract Set<String> getBoundVariables_();

	public abstract boolean isCompatible(MapPlanOperatorBase pob);

	public void setServiceGroup(MapServiceGroup serviceGroup) {
		if (serviceGroups == null) {
			serviceGroups = new HashSet<MapServiceGroup>();
		}
		serviceGroups.add(serviceGroup);
	}

	public Set<MapServiceGroup> getServiceGroups() {
		if (serviceGroups == null)
			serviceGroups = getServiceGroups_();
		return serviceGroups;
	}

	public abstract Set<MapServiceGroup> getServiceGroups_();

	public abstract void visit(MapPlanOperatorVisitor visitor);

	public int compareTo(MapPlanOperatorBase pob) {
		try {
			return new Double(this.getCosts() - pob.getCosts()).intValue();
		} catch (PlanUnfeasibleException e) {

		}
		return 0;
	}

	public boolean overlaps(MapPlanOperatorBase p2) {
		for (MapServiceGroup sg : getServiceGroups())
			if (p2.getServiceGroups().contains(sg))
				return true;
		return false;
	}

	/*
	 * Joins two MapPlanBaseOperators with just one ServiceGroup, if
	 * the Triples in the ServiceGroup were not generated by a mapping and if
	 * the variables of the Triples are equal
	 * 
	 * @returns true, if join is possible otherwise false
	 * @param MapPlanOperatorBase
	 */
	public boolean joins(MapPlanOperatorBase p2) {
		if (p2 instanceof MapOperatorServiceGroup && this instanceof MapOperatorServiceGroup) {
			Set<MapServiceGroup> setMapServiceGroupP1 = this.getServiceGroups();
			Set<MapServiceGroup> setMapServiceGroupP2 = p2.getServiceGroups();
			int similarGroupP1 = -1;
			int similarGroupP2 = -1;
			similarGroupP1 = setMapServiceGroupP1.iterator().next().getSimilar();
			similarGroupP2 = setMapServiceGroupP2.iterator().next().getSimilar();
		
			if (similarGroupP1 != similarGroupP2) {
				for (String v : getBoundVariables()) {
					if (p2.getBoundVariables().contains(v)) {
						return true;
					}
				}
			}
			return false;
		} 
		else {
			for (String v : getBoundVariables()) {
				if (p2.getBoundVariables().contains(v)) {
					return true;
				}
			return false;
			}
		}
		return false;
	}

	@Override
	public String toString() {

		try {
			return "(Costs: " + getCosts() + ")" + super.toString();
		} catch (PlanUnfeasibleException e) {
			e.printStackTrace();
		}
		return super.toString();
	}

	public abstract PlanElement toARQPlanElement(Context context);

	/**
	 * Can this Operator be the right element of an bind join operator? i.e. do
	 * the estimates change when variables are bound?
	 * 
	 * @return false - only left side...
	 */
	public abstract boolean canBeRight();

	public int size() {
		return getServiceGroups().size();
	}
}
