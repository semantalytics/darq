package de.hu_berlin.informatik.wbi.darq.cache;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import net.sf.ehcache.Cache;
import net.sf.ehcache.CacheManager;
import net.sf.ehcache.Element;

import com.hp.hpl.jena.graph.Node;
import com.hp.hpl.jena.graph.Triple;
import com.hp.hpl.jena.query.core.Var;
import com.hp.hpl.jena.query.darq.core.ServiceGroup;
import com.hp.hpl.jena.query.darq.engine.compiler.iterators.DarqQueryIterator;
import com.hp.hpl.jena.query.engine.Binding;
import com.hp.hpl.jena.query.engine.BindingMap;
import com.hp.hpl.jena.query.expr.Expr;
import com.hp.hpl.jena.query.extension.library.assign;

public class Caching {

	private static Caching instance;
	private static String configFile;
	private static boolean on = false;
	CacheManager singletonManager;
	Cache darqCache;
	Log log = LogFactory.getLog(Caching.class);
	private Caching() {
		long t2, t1, loadCacheTime;
		/* Cache parameters */
		/*
		 * see http://ehcache.sourceforge.net/documentation/configuration.html
		 * for explanation
		 */
		// String name = "DarqResultSetCache";
		// int maxElementsInMemory = 50; //TEST Werte testen
		// int maxElementsOnDisk = 0; // 0 == unlimited
		// boolean eternal = false; // Element will expire
		// boolean overflowToDisk = true; //write to disk after maxInMemory
		// boolean diskPersistent = true; // TODO TEST store to disk between
		// restarts of the VM
		// // mit maxElementOnDisk = unlimited --> Gefährlich !!
		// long timeToLiveSeconds = 0; // 0 == infinity
		// long timeToIdleSeconds = 0; // 0 == infinity
		// int diskSpoolBufferSizeMB = 30; //Buffer before storing to disk
		// MemoryStoreEvictionPolicy memoryStoreEvictionPolicy =
		// MemoryStoreEvictionPolicy.LFU;
		// String diskStorePath = System.getProperty("java.io.tempdir");
		// long diskExpiryThreadIntervalSeconds = 120;
		// RegisteredEventListeners registeredEventListeners = null;
		// BootstrapCacheLoader bootstrapCacheLoader = null;
		// singletonManager = CacheManager.create();
		// darqCache = new Cache(name,
		// maxElementsInMemory,memoryStoreEvictionPolicy,
		// overflowToDisk,diskStorePath, eternal, timeToLiveSeconds,
		// timeToIdleSeconds, diskPersistent,diskExpiryThreadIntervalSeconds,
		// registeredEventListeners,bootstrapCacheLoader,maxElementsOnDisk,diskSpoolBufferSizeMB);
		// singletonManager.addCache("DarqResultSetCache");
		/* create() use log, constructor does not */ 
		
		//t1 = System.nanoTime(); //time just for benchmark
		singletonManager = CacheManager.create(configFile);
		//t2=System.nanoTime();
		//loadCacheTime=(t2-t1);
		//System.out.println("Create Cache " + loadCacheTime /1000000);
		darqCache = singletonManager.getCache("DarqResultSetCache");
		
	}

	public synchronized static Caching getInstance(String confFile) {
		configFile = confFile;
		if (instance == null) {
			instance = new Caching();
		}
		on = true;
		return instance;
	}

	/**
	 *  add element to cache 
	 *  @param serviceGroup ServiceGroup is the Cache Key
	 *  @param bindings result of a remote service 
	 * 
	 */
	public void addElement(ServiceGroup serviceGroup, List<Binding> bindings) {
		CacheKey key;
		key = getKey(serviceGroup);
		Element el = new Element(key, bindings);
		darqCache.put(el);
		/*
		 * write to disk, bindings (and all Elements within) has to be
		 * serializable
		 */
		// System.out.println("serializable: " + el.isSerializable());//TESTAUSGABE
		// darqCache.flush();
	}

	/**
	 * @param serviceGroup ServiceGroup (cache key)
	 * @return bindings from cache
	 * get key for cache element, 
	 * get value for key 
	 * */
	public List<Binding> getElement(ServiceGroup serviceGroup) {
		List<Binding> bindings = new ArrayList<Binding>();
		List<Binding> newBindings = new ArrayList<Binding>();
		Element element;
		CacheKey key;

		key = getKey(serviceGroup);
		element = darqCache.get(key);
		/*
		 * result is filtered anyway, so you can look if an unfiltered result is
		 * in Cache
		 */
		if (!serviceGroup.getFilters().isEmpty() && element == null) {
			ServiceGroup sgWithoutFilter = serviceGroup.clone();
			List<Expr> filters = new ArrayList<Expr>();
			sgWithoutFilter.setFilters(filters);
			key = getKey(sgWithoutFilter);
			element = darqCache.get(key);
		}

		if (element != null) {
			bindings = (List<Binding>) element.getObjectValue();
			newBindings.addAll(changeVariables(bindings, serviceGroup, element));
		}
		return newBindings;
	}

	/**
	 * changes variables in cache bindings to query variables
	 * 
	 * @param cacheBindings bindings from cache
	 * @param serviceGroup	ServiceGroup generated by new query
	 * @param element Element from cache 
	 *  
	 *  */
	private List<Binding> changeVariables(List<Binding> cacheBindings, ServiceGroup serviceGroup, Element element) {

		Map<Node, Node> mappingVariables = new HashMap<Node,Node>();
		Var newVariable, cacheVariable;
		List<Binding> newBindings = new ArrayList<Binding>();

		/* get Triples from cache and query */
		List<Triple> cacheTriples = ((CacheKey) element.getObjectKey()).getServiceGroup().getTriples();
		List<Triple> newTriples = serviceGroup.getTriples();

		
		/* gets mapping for variables*/
		if (!newTriples.equals(cacheTriples)) {
			for (Triple newTriple : newTriples) {
				for (Triple cacheTriple : cacheTriples) {
					
					mappingVariables.putAll(equalTriple(newTriple, cacheTriple));
				}
			}
			/* changes variables in bindings from cache to variables from query */ 
			if (!mappingVariables.isEmpty()) {
				for (Binding cacheBinding : cacheBindings) {
					log.debug("Cache: " + cacheBinding.toString());//TESTAUSGABE
					BindingMap bm = new BindingMap();
					for (Iterator iter = cacheBinding.vars(); iter.hasNext();) {
						cacheVariable = (Var) iter.next(); 
						log.debug("Cache variable: " + cacheVariable);//TESTAUSGABE
						Node bindingValue = (Node) cacheBinding.get(cacheVariable); 
						log.debug(" Value: " + bindingValue);//TESTAUSGABE
						newVariable = (Var) mappingVariables.get(cacheVariable);
						log.debug("New variable: " + newVariable);//TESTAUSGABE
						if (bindingValue != null) {
							bm.add(newVariable, bindingValue); 
							log.debug(newVariable + " = " + bindingValue); //TESTAUSGABE
						}
					}
					newBindings.add(bm);
				}
			}
		}
		else{
			newBindings = cacheBindings;
		}
		return newBindings;
	}

	/**
	 * creates the key for the caching object from ServiceGroup
	 * @param serviveGroup
	 * @return Key for cache object
	 */
	private CacheKey getKey(ServiceGroup serviceGroup) {
		CacheKey key;
		Node s, p, o;
		String subj, pred, obj;
		subj = null;
		pred = null;
		obj = null;
		List<CacheTripleVariables> listCTV =  new ArrayList<CacheTripleVariables>();
		List<TripleStringURI> tripleList = new ArrayList<TripleStringURI>();
		List<Triple> triples = serviceGroup.getTriples();
		for (Triple triple : triples) {
			s = triple.getSubject();
			if (s.isConcrete())
				subj = s.toString();
			p = triple.getPredicate();
			if (p.isConcrete())
				pred = p.toString();
			o = triple.getObject();
			if (o.isConcrete())
				obj = o.toString();
			TripleStringURI tripleURI = new TripleStringURI(subj, pred, obj);
			tripleList.add(tripleURI);
		}
		listCTV = equalVariables(serviceGroup.getTriples());
		key = new CacheKey(tripleList, serviceGroup.getService().getUrl(), serviceGroup.getFilters().toString(), serviceGroup, listCTV);
		return key;
	}

	/**
	 *  looks if triples are equal, if true return variable mapping
	 * @param newTriple Triple from ServiceGroup (new query)
	 * @param cacheTriple Triple from cache result (cached query)
	 * @return mapping of variables
	 *  */
	private Map<Node, Node> equalTriple(Triple newTriple, Triple cacheTriple) {
		HashMap<Node, Node> mappingVariables = new HashMap<Node, Node>();
		Boolean subj, pred, obj;
		Node s, p, o, cacheS, cacheP, cacheO;
		subj = false;
		pred = false;
		obj = false;

		s = newTriple.getSubject();
		cacheS = cacheTriple.getSubject();
		if (s.isConcrete()) {
			subj = s.equals(cacheS);
		} else {
			subj = true;
			mappingVariables.put(cacheS, s);
		}

		p = newTriple.getPredicate();
		cacheP = cacheTriple.getPredicate();
		if (p.isConcrete()) {
			pred = p.equals(cacheP);
		} else {
			pred = true;
			mappingVariables.put(cacheP, p);
		}

		o = newTriple.getObject();
		cacheO = cacheTriple.getObject();
		if (o.isConcrete()) {
			obj = o.equals(cacheO);
		} else {
			obj = true;
			mappingVariables.put(cacheO, o);
		}

		if (subj && pred && obj) {
			return mappingVariables;
		} else {
			return new HashMap<Node,Node>();
		}
	}
	
	private List<CacheTripleVariables> equalVariables(List<Triple> triples) {
		Node aS, aP, aO, bS, bP, bO;
		List<CacheTripleVariables> listCTV = new ArrayList<CacheTripleVariables>();
		if (triples.size() > 1) {
			for (Triple tripleA : triples) {
				aS = tripleA.getSubject();
				aP = tripleA.getPredicate();
				aO = tripleA.getObject();
				for (Triple tripleB : triples) {
					if (!tripleA.equals(tripleB)) {
						CacheTripleVariables ctv = new CacheTripleVariables(tripleA, tripleB);
						bS = tripleB.getSubject();
						bP = tripleB.getPredicate();
						bO = tripleB.getObject();
						if (aS.isVariable()) {
							if (bS.isVariable()) {
								if (aS.equals(bS)) {
									ctv.setSs(aS.toString());
								}
							}
							if (bP.isVariable()) {
								if (aS.equals(bP)) {
									ctv.setSp(aS.toString());
								}
							}
							if (bO.isVariable()) {
								if (aS.equals(bO)) {
									ctv.setSo(aS.toString());
								}
							}
						}
						if (aP.isVariable()) {
							if (bS.isVariable()) {
								if (aP.equals(bS)) {
									ctv.setPs(aP.toString());
								}
							}
							if (bP.isVariable()) {
								if (aP.equals(bP)) {
									ctv.setPp(aP.toString());
								}
							}
							if (bO.isVariable()) {
								if (aP.equals(bO)) {
									ctv.setPo(aP.toString());
								}
							}
						}
						if (aO.isVariable()) {
							if (bS.isVariable()) {
								if (aO.equals(bS)) {
									ctv.setOs(aO.toString());
								}
							}
							if (bP.isVariable()) {
								if (aO.equals(bP)) {
									ctv.setOp(aO.toString());
								}
							}
							if (bO.isVariable()) {
								if (aO.equals(bO)) {
									ctv.setOo(aO.toString());
								}
							}
						}
//						ctv.output(); // TESTAUSGABE
						listCTV.add(ctv);
					}
				}
			}
		}
		return listCTV;
	}

	/**
	 * write cache to commandline
	 * Just for test purpose!
	 * */
	public void output() {
		System.out.println("---------- BEGIN CACHE CONTENT ----------");
		System.out.println("Cache Memory Size: " + darqCache.getMemoryStoreSize());
		System.out.println("Cache Disk Size: " + darqCache.getDiskStoreSize());
		for (Object key : darqCache.getKeys()) {
			CacheKey cacheKey = (CacheKey) key;
			System.out.println("Key:" + key.hashCode());
			Element element = darqCache.get(cacheKey);
			List<Binding> werte = (List<Binding>) element.getValue();
			for (Binding sol : werte) {
				System.out.println("   Value" + sol.toString());
			}
		}
		System.out.println("---------- END CACHE CONTENT ----------");
	}

	/**
	 * removes cache
	 * */
	public void removeCache() {
		/* write to disk */
		// darqCache.flush();
		singletonManager.removalAll();
		singletonManager.shutdown();
	}

	/**
	 * @return true if cache option was enabled
	 * */
	public boolean isEnabled() {
		return on;
	}

	/**
	 * @return path of config file for cache 
	 * */
	public String getConfigFile() {
		return configFile;
	}

}
