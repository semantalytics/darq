<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Federated Queries with SPARQL</title>


  <style type="text/css">
body { margin: 3em 4em;
max-width: 36em;
}
h1 { margin: 1em 0pt 1.5em;
font-size: 200%;
text-align: center;
}
h2 { margin: 1.8em 0pt 0.3em;
font-size: 140%;
}
h3 { margin: 1.8em 0pt 0.3em;
font-size: 100%;
}
p { margin: 0pt 0pt 1em;
}
dt { margin: 2em 0pt 1em;
}
dt, dt tt { font-weight: bold;
}
dt tt { font-size: 120%;
}
ul { padding-left: 1.2em;
margin-left: 0pt;
}
ol { padding-left: 1.5em;
margin-left: 0pt;
}
li { margin: 0pt 0pt 0.4em;
padding: 0pt;
}
pre { padding: 1em 0pt 1em 1.5em;
background: rgb(238, 238, 238) none repeat scroll 0% 50%;
-moz-background-clip: initial;
-moz-background-origin: initial;
-moz-background-inline-policy: initial;
overflow: visible;
}
tt { font-size: 90%;
}
h1, h2, h3, dt, strong { font-family: Helvetica,Arial,sans-serif;
color: rgb(0, 0, 153);
}
.footer { border-top: 1px solid black;
margin: 3em 0pt 0pt;
}
@media print {
body { margin: 0pt;
font-size: 11pt;
}
}
  </style>
</head>
<body>

<h1>Federated Queries with SPARQL</h1>

<div style="text-align: center;">Bastian Quilitz, HP Labs
Bristol</div>

<p></p>

<p>Last update:&nbsp;</p>

<h2>Overview</h2>

<p>sparql2sql is a query engine for
<a href="http://www.w3.org/TR/rdf-sparql-query/">SPARQL</a>
over <a href="http://jena.sourceforge.net/">Jena</a>
triple stores.
It rewrites SPARQL queries into SQL. This approach offloads most of
the query execution work on the database. This should improve
performance.</p>

<p></p>

<p>This is an experimental implementation. It cannot deal with
all
SPARQL queries and is not fully tested. See the <a href="#issues">
Limitations and known issues</a> sections for some details.</p>

<ul>

  <li>Tested only on MySQL 4.1, will not work on older MySQL
versions</li>

  <li>Based on Andy Seaborne's <a href="http://jena.hpl.hp.com/%7Eafs/ARQ/">ARQ</a>,
which handles parsing, FILTER evaluation, result ordering and limiting
and
CONSTRUCT</li>

  <li>Source code is available through anonymous CVS and
    <a href="http://cvs.sourceforge.net/viewcvs.py/jena/sparql2sql/">browsable
online</a></li>

  <li>BSD licensed</li>

</ul>

<p>Please direct feedback and bug reports to the Jena mailing
list,
<a href="mailto:jena-dev@groups.yahoo.com">jena-dev@groups.yahoo.com</a>.</p>

<p>Author: Richard Cyganiak
(<a href="mailto:richard@cyganiak.de">richard@cyganiak.de</a>)</p>

<h2>Contents</h2>

<ol>

  <li><a href="#download">Download and CVS access</a></li>

  <li><a href="#example_model">Example: Querying a
persistent Jena model</a></li>

  <li><a href="#example_dataset">Example: Working
with RDF Datasets and named graphs</a></li>

  <li><a href="#issues">Limitations and known issues</a></li>

  <li><a href="#schema">Database schema</a></li>

  <li><a href="#mapping">SPARQL to SQL mapping
details</a></li>

</ol>

<h2 id="download">Download and CVS access</h2>

<p>Currently sparql2sql is only available as Java source code
from CVS.</p>

<pre>cvs -d:pserver:anonymous@cvs.sourceforge.net:/cvsroot/jena login<br>cvs -z3 -d:pserver:anonymous@cvs.sourceforge.net:/cvsroot/jena co sparql2sql</pre>

<p>When asked for a password, just press Enter.</p>

<p>All required jar files (the Jena 2.2 jars, the MySQL JDBC
connector,
and a CVS build of ARQ) are in the <tt>lib</tt> directory.</p>

<p>There's a runnable example, <tt>sparql2sql/Test.java</tt>,
and a unit
test suite in the <tt>tests-src</tt> directory. Both
require a live
MySQL 4.1 database. The connection is configured in
<tt>etc/db_connection.properties</tt>.</p>

<h2 id="example_model">Example: Querying a persistent Jena
model</h2>

<p>sparql2sql can be used to query database-persisted Jena models
(ModelRDB).
The example creates a ModelRDB, reads an RDF file into the model, then
re-opens the model as an RDBDataSource and executes a SPARQL query on
that.</p>

<pre>// register the sparql2sql query engine<br>// (must be done once at startup time)<br>RDBQueryEngineFactory.registerSelf();<br>// Open a DB connection and DB model<br>IDBConnection conn = new DBConnection(url, user, password, engine);<br>ModelMaker maker = ModelFactory.createModelRDBMaker(conn);<br>Model persistentModel = maker.createModel("myModelName");<br>// ... do interesting stuff with the model ...<br>persistentModel.read("http://xmlns.com/foaf/0.1/index.rdf");<br>// Open the same model as an ARQ DataSet<br>DataSet ds = RDBDataSource.open(conn, "myModelName");<br>// Execute a SPARQL query<br>String sparql =<br>"PREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; " +<br>"PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; " +<br>"SELECT ?class ?label " +<br>"WHERE { ?class rdf:type rdfs:Class . " +<br>" ?class rdfs:label ?label }";<br>ResultSet results = QueryExecutionFactory.create(<br>QueryFactory.create(sparql), ds).execSelect();<br>// Pretty-print results to System.out<br>new ResultSetFormatter(results).printAll(System.out);</pre>

<h2 id="example_dataset">Example: Working with RDF
Datasets and named graphs</h2>

<p>SPARQL's Dataset is a collection consisting of a <em>default
graph</em>
and any number of <em>named graphs</em>, which are named
by URIs.</p>

<p>sparql2sql's implementation of this concept is the
RDBDataSource.</p>

<p>The example sets up an RDBDataSource, reads some RDF file into
the
default graph and some named graphs, and executes a SPARQL query
over the Dataset.</p>

<pre>// set up datasource<br>RDBDataSource ds = RDBDataSource.open(<br>new DBConnection(url, user, password, engine),<br>"my_dataset");<br>// clean the model if it still contains stuff from previous run<br>ds.clear();<br>// randomly read some RDF into the default and some named graphs<br>ds.getDefaultModel().read("http://www.w3.org/1999/02/22-rdf-syntax-ns");<br>// we have to generate the named graphs first -- clunky!<br>ds.addNamedModel("urn:my:graph1", ModelFactory.createDefaultModel());<br>ds.addNamedModel("urn:my:graph2", ModelFactory.createDefaultModel());<br>ds.addNamedModel("urn:my:graph3", ModelFactory.createDefaultModel());<br>// now read some stuff<br>ds.getNamedModel("urn:my:graph1").read("http://www.w3.org/2000/01/rdf-schema");<br>ds.getNamedModel("urn:my:graph2").read("http://purl.org/dc/elements/1.1/");<br>ds.getNamedModel("urn:my:graph3").read("http://xmlns.com/foaf/0.1/index.rdf");<br>// register the SPARQL2SQL query engine -- must be done once at<br>// startup time<br>RDBQueryEngineFactory.registerSelf();<br>// Set log level to debug<br>// This causes the engine to log executed SELECT statements<br>Logger.getLogger(RDBDataSource.class).setLevel(Level.DEBUG);<br>// do a SPARQL query<br>String sparql =<br>"PREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; " +<br>"PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; " +<br>"SELECT ?source ?uri ?superclass " +<br>"WHERE { GRAPH ?source { " +<br>"{ ?uri rdf:type rdfs:Class } UNION { ?uri rdf:type rdf:Property } " +<br>"OPTIONAL { ?uri rdfs:subClassOf ?superclass } } }";<br>Query q = QueryFactory.create(sparql);<br>ResultSet results = QueryExecutionFactory.create(q, ds).execSelect();<br>// print results using an ARQ utility class<br>ResultSetFormatter.out(System.out, results, q);<br>// close the dataset<br>ds.close();</pre>

<h2 id="issues">Limitations and known issues</h2>

<p>This is experimental software in a very early stage of
development.
No extensive testing has been performed.</p>

<ul>

  <li><strong>sparql2sql will not work in conjunction with
the RDF reification
vocabulary</strong></li>

  <li>sparql2sql cannot query inference models, unless all
inferences are stored
in the database</li>

  <li>The software has been tested with MySQL 4.1. It should, in
principle, work with
other database engines supported by Jena, but not with older versions
of MySQL
because they don't support nested SELECTs</li>

  <li>FILTER clauses inside OPTIONAL patterns do not work</li>

  <li>Order-dependent queries do not work:
    <pre>WHERE { ?x :a :b OPTIONAL { ?x :c1 ?y } OPTIONAL { ?x :c2 ?y } }</pre>

(The results depend on which ?y is bound &ldquo;first&rdquo;)</li>

  <li>Some queries will not work when multiple DataSets are
stored in the same
database instance. This affects graph name patterns without required
triple pattern:
    <pre>WHERE { GRAPH ?g {} }</pre>

    <pre>WHERE { GRAPH ?g { OPTIONAL { ?s ?p ?o } } }</pre>

  </li>

  <li>Some complex graph patterns involving UNIONs or nested
OPTIONALs with
many occurences of the same variables will not work; these are not very
likely to surface in real-world SPARQL queries.</li>

  <li>Queries that do &ldquo;not work&rdquo; might merely
run extremely slow,
might return wrong results, or might cause the system to halt and
catch fire.</li>

</ul>

<h2 id="schema">Database schema</h2>

<p>sparql2sql uses the <a href="http://jena.sourceforge.net/DB/layout.html">Jena
ModelRDB database schema</a>.</p>

<p>This allows SPARQL queries over existing ModelRDB stores, but
comes
at a performance and complexity cost since the Jena DB schema was not
designed with RDF Datasets in mind.</p>

<p>ModelRDB is able to store multiple models in a single
statement table.
This feature is used by sparql2sql to simulate RDF Datasets. The model
ID is used to store graph name URIs. The URIs are encoded using
ModelRDB's node encoding scheme to improve join performance.</p>

<h2 id="mapping">SPARQL to SQL mapping details</h2>

<ul>

  <li>Groups of triple patterns are rewritten into joins over
aliases of
the statement table</li>

  <li>OPTIONALs are rewritten into LEFT JOINs over nested SELECTs</li>

  <li>UNIONs are rewritten into SQL UNIONs</li>

  <li>GRAPHs cause nested triples to be handled as quads, and/or
are
matched against the graph name table</li>

  <li>FILTERs are not handled by the database, but evaluated in
Java code</li>

  <li>FILTERs in OPTIONALs are not supported</li>

  <li>For FILTERs in UNIONs, flag columns are introduced; they
mark wether
the constraint applies to a given result row</li>

  <li>Order-dependent patterns <em>should</em> be
handled by OUTER JOINs,
but are not supported at the moment</li>

  <li>Some corner cases are not supported, and either recognised
and deferred
to ARQ's general-purpose query engine, or will give wrong results, or
will cause an exception</li>

</ul>

<p>Generated SQL statements can be logged by lowering the log
level:</p>

<pre>Logger.getLogger(RDBDataSource.class).setLevel(Level.DEBUG);</pre>

<div class="footer">$ID$<br>

</div>

</body>
</html>
